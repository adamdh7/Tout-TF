<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TF-Stream-7</title>
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#2563eb" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="TF-Stream-7" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body{font-family:-apple-system,BlinkMacSystemFont,"SF Pro Display",sans-serif;background:#f9f9fb;color:#111;margin:0}
    header{display:flex;align-items:center;justify-content:center;padding:12px 16px;font-size:18px;font-weight:700;background:#fff;box-shadow:0 1px 3px rgba(0,0,0,0.05);position:sticky;top:0;z-index:20}
    .header-controls{position:absolute;right:16px;top:50%;transform:translateY(-50%);display:flex;gap:8px;align-items:center}
    .title{display:flex;gap:12px;align-items:center}
    .badge-new{background:#ef4444;color:#fff;padding:6px 10px;border-radius:999px;font-weight:700;font-size:13px}
    .show-btn{background:#111827;color:#fff;border-radius:8px;padding:6px 10px;border:none;cursor:pointer}
    .search-bar{margin:12px;display:flex;justify-content:center}
    input{width:90%;max-width:700px;padding:10px 14px;border-radius:12px;border:1px solid #ddd;font-size:16px;outline:none}
    .container{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px;padding:16px}
    .card{background:#fff;border-radius:14px;box-shadow:0 3px 6px rgba(0,0,0,0.06);overflow:hidden;display:flex;flex-direction:column;transition:transform .18s}
    .card:hover{transform:translateY(-3px)}
    .thumb{width:100%;aspect-ratio:16/9;object-fit:cover;background:#f1f1f1}
    .info{padding:12px 14px;display:flex;flex-direction:column;gap:8px}
    .name{font-weight:600;font-size:15px;word-break:break-word;white-space:normal}
    .suburl{font-size:11px;color:#888;word-break:anywhere}
    .group-head{grid-column:1/-1;padding:8px 12px;background:rgba(0,0,0,0.03);border-radius:12px;font-weight:700;color:#222;display:flex;justify-content:space-between;align-items:center;gap:12px}
    .season-head{grid-column:1/-1;padding:6px 12px;background:rgba(0,0,0,0.02);border-radius:10px;font-weight:700;color:#333;display:flex;justify-content:flex-start;align-items:center;gap:12px}
    .meta{font-size:13px;color:#777}
    .actions{display:flex;gap:8px;flex-wrap:wrap}
    .prefix-span{cursor:pointer;user-select:all;border-radius:6px;padding:6px 8px;background:#111827;color:#fff;font-weight:700}
    .prefix-span:active{transform:translateY(1px)}
    button{background:#007aff;border:none;color:#fff;padding:8px 12px;border-radius:10px;cursor:pointer}
    button:hover{background:#0065d0}
    .small-btn{padding:6px 10px;font-size:13px;background:#111827;color:#fff;border-radius:8px;border:none}
    .empty{text-align:center;color:#888;margin-top:40px}
    .copy-all-btn{padding:6px 10px;font-size:13px;background:#111827;color:#fff;border-radius:8px;border:none;cursor:pointer}
    .copy-all-btn.copied{background:#10b981}
    .badge-new{margin-left:8px}
    #fileList{min-height:120px}
  </style>
</head>
<body>
  <header>
    <div class="title"><span>TF-Stream-7</span></div>
    <div class="header-controls">
      <div id="newIndicator" style="display:none" class="badge-new">Nouveaux: <span id="newCount">0</span></div>
      <button id="showNewBtn" class="show-btn" style="display:none">Afficher</button>
    </div>
  </header>

  <div class="search-bar">
    <input id="searchInput" type="text" placeholder="Rechercher par nom, épisode, season, URL..." />
  </div>

  <div id="fileList" class="container"></div>
  <div id="emptyMessage" class="empty" style="display:none">Aucun fichier trouvé.</div>

<script>
(() => {
  const CONFIG = {
    FILES_PATH: '/files',
    WS_PATH: (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws',
    SSE_PATH: '/events',
    POLL_INTERVAL_MS: 12000,
    BATCH_FLUSH_MS: 700,
    CHUNK_SIZE: 50,
    MAX_RENDER: 1200,
    METADATA_CAP: 30000,
    FLUSH_BATCH_ON_SCROLL: 4,
    AUTO_FLUSH_ON_SCROLL: true,
    SILENT_FLUSH_INTERVAL_MS: 5000,
    MAX_VIDEOS_RENDER: 8
  };

  const toNum = v => (v === undefined || v === null) ? 0 : Number(v) || 0;
  const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });

  window.allFiles = [];
  window.viewFiles = [];
  let ws = null, es = null, pollTimer = null, reconnectAttempts = 0;
  let pendingMsgs = [];
  let silentLogCache = [];
  let renderedCount = 0;
  let sentinelObserver = null;

  function normalizeString(s) {
    if (!s) return '';
    try { s = s.normalize('NFKD').replace(/[\u0300-\u036f]/g,''); } catch(e){}
    try { s = s.replace(/[^\p{L}\p{N}]+/gu,' '); } catch(e) { s = s.replace(/[^A-Za-z0-9]+/g,' '); }
    return s.replace(/\s+/g,' ').trim().toLowerCase();
  }

  function isImageFile(name){ return !!(name||'').match(/\.(jpg|jpeg|png|gif|webp)$/i); }
  function isVideoFile(name){ return !!(name||'').match(/\.(mp4|mov|webm|mkv)$/i); }

  function removeBracketed(s){
    if(!s) return s;
    return s.replace(/[\(\{][^\)\}]*[\]\)\}]/g,'').replace(/\s+/g,' ').trim();
  }

  function stripPrefixes(noExt){
    if(!noExt) return '';
    let s = noExt;
    s = s.replace(/^[0-9]{6,}[_\-]*/,''); // keep as fallback but we also handle leadingNumeric in parseParts
    s = s.replace(/^[\{\[][^)\}]*[\)\]\}][_-\s]*/,'');
    s = s.replace(/^@[^_\-\s]+[_\-\s]*/g,'').replace(/^[_\-]+@[^_\-\s]+[_\-\s]*/g,'');
    s = s.replace(/[_\-]*@[^_\s\-_]+[_\-]*/g,' ');
    s = s.replace(/[_\-\.\s]+/g,' ');
    s = s.replace(/\s+/g,' ').trim();
    return s;
  }

  /* parseParts improvements:
     - remove LONG leading numeric prefix (timestamp/id) BEFORE computing base/numericToken
     - preserve that prefix in leadingNumeric so we can show clickable copy
     - numericToken = last number in the remaining string (used as ep indicator)
  */
  function parseParts(name){
    const noExt = (name||'').replace(/\.[^.]+$/,'');
    let rawNorm = removeBracketed(noExt).replace(/[_\-\.\s]+/g,' ').replace(/\s+/g,' ').trim();

    // detect and strip a leading numeric prefix (threshold: 4+ digits). Keep it.
    let leadingNumeric = null;
    const mLead = rawNorm.match(/^(\d{4,}|\d{6,})[-_\s]*/);
    if(mLead){
      leadingNumeric = mLead[1].replace(/[-_\s]/g,'');
      rawNorm = rawNorm.replace(new RegExp('^' + mLead[0].replace(/([.*+?^=!:${}()|[\]/\\])/g,'\\$1')), '').trim();
    } else {
      // also try simpler: digits followed by dash/underscore (for short IDs), but be conservative (>=4)
      const m2 = rawNorm.match(/^(\d{4,})[-_\s]+/);
      if(m2){ leadingNumeric = m2[1]; rawNorm = rawNorm.replace(new RegExp('^' + m2[0].replace(/([.*+?^=!:${}()|[\]/\\])/g,'\\$1')), '').trim(); }
    }

    // now explicit season/ep detection
    let season = null, ep = null, hasSeason=false, hasEp=false;
    let m;
    m = rawNorm.match(/[sS][\s._\-:]*0*(\d{1,3})[\s._\-]*[eE][\s._\-:]*0*(\d{1,3})/);
    if(m){ season = toNum(m[1]); ep = toNum(m[2]); hasSeason=true; hasEp=true; }
    if(!hasSeason || !hasEp){
      m = rawNorm.match(/[eE][\s._\-:]*0*(\d{1,3})[\s._\-]*[sS][\s._\-:]*0*(\d{1,3})/);
      if(m){ ep = toNum(m[1]); season = toNum(m[2]); hasSeason=true; hasEp=true; }
    }
    if(!hasSeason || !hasEp){
      m = rawNorm.match(/\b(?:season|saison)[\s._\-:]*0*(\d{1,3})[\s,._\-]*\b(?:ep(?:isode)?|e)[\s._\-:]*0*(\d{1,3})/i);
      if(m){ season = toNum(m[1]); ep = toNum(m[2]); hasSeason=true; hasEp=true; }
    }
    if(!hasSeason){
      m = rawNorm.match(/\b[sS][\s._\-:]*0*(\d{1,3})\b/);
      if(m){ season = toNum(m[1]); hasSeason = true; }
      else {
        m = rawNorm.match(/\b(?:season|saison)[\s._\-:]*0*(\d{1,3})\b/i);
        if(m){ season = toNum(m[1]); hasSeason = true; }
      }
    }
    if(!hasEp){
      m = rawNorm.match(/\b(?:ep(?:isode)?|episode|[eE])[\s._\-:]*0*(\d{1,3})\b/i);
      if(m){ ep = toNum(m[1] || m[0].replace(/\D/g,'')); hasEp = true; }
    }

    // If no explicit season/ep found, capture the LAST numeric token in rawNorm as numericToken
    let numericToken = null;
    if(!hasSeason && !hasEp){
      const nums = Array.from((rawNorm.match(/\d{1,6}/g) || []).map(x => Number(x)));
      if(nums.length) numericToken = nums[nums.length - 1];
    }

    // Build base string removing season/ep tokens & trailing numeric token if it was detected
    let baseRaw = rawNorm;
    if(hasSeason || hasEp){
      baseRaw = baseRaw.replace(/[sS][\s._\-:]*0*(\d{1,3})[\s._\-]*[eE][\s._\-:]*0*(\d{1,3})/g,' ');
      baseRaw = baseRaw.replace(/[eE][\s._\-:]*0*(\d{1,3})[\s._\-]*[sS][\s._\-:]*0*(\d{1,3})/g,' ');
      baseRaw = baseRaw.replace(/\b(?:season|saison)[\s._\-:]*0*(\d{1,3})\b/ig,' ');
      baseRaw = baseRaw.replace(/\b(?:ep(?:isode)?|episode|[eE])[\s._\-:]*0*(\d{1,3})\b/ig,' ');
    } else if(numericToken != null){
      // remove the last numeric token only
      baseRaw = baseRaw.replace(new RegExp('\\b' + String(numericToken) + '\\b' + '\\s*$'), ' ');
    }

    baseRaw = baseRaw.replace(/\b(vf|vostfr|vost|fr|sub|dub)\b/gi,'').replace(/\s+/g,' ').trim();
    const base = normalizeString(baseRaw || rawNorm);

    return {
      base,
      season: (season != null) ? toNum(season) : null,
      ep: (ep != null) ? toNum(ep) : null,
      numericToken: (numericToken != null) ? Number(numericToken) : null,
      leadingNumeric: leadingNumeric,
      hasSeason: !!hasSeason,
      hasEp: !!hasEp,
      raw: rawNorm
    };
  }

  function intraGroupCompare(a,b){
    const pa = parseParts(a.name||''), pb = parseParts(b.name||'');
    const aIsBaseOnly = (!pa.hasEp && pa.ep==null) && (!pa.hasSeason && pa.season==null);
    const bIsBaseOnly = (!pb.hasEp && pb.ep==null) && (!pb.hasSeason && pb.season==null);
    if(aIsBaseOnly && !bIsBaseOnly) return 1;
    if(bIsBaseOnly && !aIsBaseOnly) return -1;
    const sa = pa.season!=null ? toNum(pa.season) : (pa.hasEp ? 1 : 0);
    const sb = pb.season!=null ? toNum(pb.season) : (pb.hasEp ? 1 : 0);
    const ea = pa.ep!=null ? toNum(pa.ep) : (pa.hasSeason ? 0 : 999999);
    const eb = pb.ep!=null ? toNum(pb.ep) : (pb.hasSeason ? 0 : 999999);
    if(sa !== sb) return sa - sb;
    if(ea !== eb) return ea - eb;
    const lmA = toNum(a.lastModified), lmB = toNum(b.lastModified);
    if(lmA !== lmB) return lmB - lmA;
    const aNoExt = (a.name||'').replace(/\.[^.]+$/,'');
    const bNoExt = (b.name||'').replace(/\.[^.]+$/,'');
    return collator.compare(aNoExt,bNoExt);
  }

  function createGroupHeader(f){
    const head = document.createElement('div'); head.className = 'group-head';
    const left = document.createElement('div'); left.className = 'group-title';
    const pretty = (f.base || '(sans nom)').replace(/[_\-\s]+/g,' ').trim();
    left.textContent = pretty;
    head.appendChild(left);
    const rightWrap = document.createElement('div'); rightWrap.style.display='flex'; rightWrap.style.gap='8px'; rightWrap.style.alignItems='center';
    const right = document.createElement('div'); right.style.fontSize='13px'; right.style.color='#555'; right.style.whiteSpace='nowrap'; right.textContent = f.newest ? ('Dernier upload : ' + new Date(Number(f.newest)).toLocaleString()) : '';
    rightWrap.appendChild(right);
    const copyAllBtn = document.createElement('button'); copyAllBtn.className='copy-all-btn'; copyAllBtn.title='Copier tous les Name Saison X ep Y + Url'; copyAllBtn.innerHTML = 'Copier tout';
    copyAllBtn.addEventListener('click', (ev) => { ev.stopPropagation(); try{ copyGroup(f.base); } catch(e){ console.error(e); } copyAllBtn.classList.add('copied'); setTimeout(()=>copyAllBtn.classList.remove('copied'),1200); });
    rightWrap.appendChild(copyAllBtn);
    head.appendChild(rightWrap);
    return head;
  }

  function createSeasonHeader(obj){
    const head = document.createElement('div'); head.className = 'season-head';
    const left = document.createElement('div'); left.className = 'season-title';
    left.textContent = obj.seasonLabel || (obj.season === 'base' ? 'Base' : ('Saison ' + obj.season));
    head.appendChild(left);
    if(obj.note){
      const note = document.createElement('div'); note.style.fontSize='12px'; note.style.color='#666'; note.textContent = obj.note;
      head.appendChild(note);
    }
    return head;
  }

  function niceDisplayName(f){
    const p = parseParts(f.name || '');
    const basePretty = (p.raw || f.name || '').replace(/[_\-\s]+/g,' ').trim();
    if(p.hasSeason || p.hasEp){
      const s = (p.season != null) ? p.season : (p.hasEp ? 1 : null);
      const e = (p.ep != null) ? p.ep : (p.hasEp ? (p.ep || '') : '');
      if(s != null && e != null && e !== '') return `${basePretty} Saison ${s} ep ${e}`;
      if(s != null && (e === '' || e == null)) return `${basePretty} Saison ${s}`;
    }
    if(f.__displaySeason != null){
      const s = f.__displaySeason;
      const e = f.__displayEp != null ? f.__displayEp : '';
      if(e !== '') return `${basePretty} Saison ${s} ep ${e}`;
      return `${basePretty} Saison ${s}`;
    }
    const rawName = removeBracketed((f.name || '').replace(/\.[^.]+$/,''));
    return rawName || '(sans nom)';
  }

  function createCardElement(f, createVideo=true){
    if(f.__groupHeader) return createGroupHeader(f);
    if(f.__seasonHeader) return createSeasonHeader(f);
    const card = document.createElement('div'); card.className = 'card';
    const isVideo = isVideoFile(f.name||'');
    const isImage = isImageFile(f.name||'');
    let preview;
    if(isVideo && createVideo){
      const vid = document.createElement('video'); vid.className='thumb'; vid.src = f.url; vid.controls = true; vid.preload='metadata'; preview = vid;
    } else if(isImage){
      const img = document.createElement('img'); img.className='thumb'; img.alt = f.name||''; img.src = f.url; preview = img;
    } else if(isVideo && !createVideo){
      const div = document.createElement('div'); div.className='thumb'; div.style.display='flex'; div.style.alignItems='center'; div.style.justifyContent='center'; div.style.cursor='pointer'; div.textContent='Cliquer pour lire';
      div.addEventListener('click', ()=>{ const vid=document.createElement('video'); vid.className='thumb'; vid.src=f.url; vid.controls=true; vid.preload='metadata'; div.replaceWith(vid); }, { once:true });
      preview = div;
    } else {
      const div = document.createElement('div'); div.className='thumb'; div.style.display='flex'; div.style.alignItems='center'; div.style.justifyContent='center'; div.style.color='#999'; div.textContent='Pas d’aperçu'; preview = div;
    }

    const info = document.createElement('div'); info.className='info';
    const nameRow = document.createElement('div'); nameRow.style.display='flex'; nameRow.style.alignItems='center'; nameRow.style.gap='8px';

    // leading numeric clickable prefix
    const p = parseParts(f.name || '');
    if(p.leadingNumeric){
      const pref = document.createElement('span');
      pref.className = 'prefix-span';
      pref.textContent = p.leadingNumeric;
      pref.title = 'Cliquer pour copier le préfixe';
      pref.addEventListener('click', (ev)=>{ ev.stopPropagation(); copyText(p.leadingNumeric); pref.style.background='#10b981'; setTimeout(()=>pref.style.background='#111827',900); });
      nameRow.appendChild(pref);
    }

    const nameDiv = document.createElement('div'); nameDiv.className = 'name'; nameDiv.textContent = niceDisplayName(f);
    nameRow.appendChild(nameDiv);
    info.appendChild(nameRow);

    if(f.__isNewestForEpisode){
      const badge = document.createElement('span'); badge.className='badge-new'; badge.textContent='NOUVO'; badge.style.fontSize='11px'; badge.style.padding='4px 8px'; badge.style.marginLeft='8px';
      nameRow.appendChild(badge);
    }

    const metaDiv = document.createElement('div'); metaDiv.className='meta'; const sizeMB = ((toNum(f.size)||0)/1048576).toFixed(1); const lm = f.lastModified ? new Date(Number(f.lastModified)).toLocaleString() : '-'; metaDiv.textContent = `${sizeMB} MB • ${lm}`;
    const actions = document.createElement('div'); actions.className='actions';
    const copyBtn = document.createElement('button'); copyBtn.className='small-btn'; copyBtn.textContent='Copier URL'; copyBtn.addEventListener('click', ()=>copyUrl(f.url));
    const openA = document.createElement('a'); openA.href = f.url; openA.target = '_blank';
    const openBtn = document.createElement('button'); openBtn.className='small-btn'; openBtn.textContent='Ouvrir'; openA.appendChild(openBtn);
    const urlSpan = document.createElement('div'); urlSpan.className='suburl'; urlSpan.textContent = insertSoftBreaks(f.url || '',50);
    actions.appendChild(copyBtn); actions.appendChild(openA);
    info.appendChild(metaDiv); info.appendChild(actions); info.appendChild(urlSpan);
    card.appendChild(preview); card.appendChild(info);
    return card;
  }

  // buildOrderedList with corrected leading-numeric stripping and grouping logic
  function buildOrderedList(files){
    const groups = new Map();
    (files||[]).forEach(f=>{
      try {
        const p = parseParts(f.name||'');
        if(isImageFile(f.name)){
          const imgKey = 'img::' + (f.url || f.name || String(Math.random()));
          if(!groups.has(imgKey)) groups.set(imgKey, []);
          groups.get(imgKey).push(f);
          return;
        }
        const baseKey = (p && p.base) ? p.base : normalizeString((f.name||'').replace(/\.[^.]+$/,'')) || (f.name||'').replace(/\.[^.]+$/,'');
        if(!groups.has(baseKey)) groups.set(baseKey,[]);
        groups.get(baseKey).push(f);
      } catch(e) {
        const fallback = (f.name||'').replace(/\.[^.]+$/,'');
        if(!groups.has(fallback)) groups.set(fallback,[]);
        groups.get(fallback).push(f);
      }
    });

    const groupArr = Array.from(groups.entries()).map(([base,items]) => {
      const newest = items.reduce((m,it) => Math.max(m,toNum(it.lastModified)),0);
      return { base, items, newest };
    });

    // most recently updated groups first
    groupArr.sort((g1,g2) => {
      const a = toNum(g2.newest) - toNum(g1.newest);
      if(a !== 0) return a;
      return collator.compare(g1.base, g2.base);
    });

    const out = [];
    for(const g of groupArr){
      // images: push directly
      if(typeof g.base === 'string' && g.base.startsWith('img::')){
        g.items.sort((x,y)=> toNum(y.lastModified) - toNum(x.lastModified));
        for(const it of g.items) out.push(it);
        continue;
      }

      // parse items
      const parsed = g.items.map(it => ({ it, p: parseParts(it.name || '') }));

      const explicitSeason = parsed.filter(x => x.p.hasSeason || x.p.hasEp).map(x=>x.it);
      const numericItems = parsed.filter(x => !(x.p.hasSeason || x.p.hasEp) && x.p.numericToken != null);
      const baseOnly = parsed.filter(x => !(x.p.hasSeason || x.p.hasEp) && x.p.numericToken == null).map(x=>x.it);

      // group numericItems by numericToken
      const numMap = new Map();
      for(const ni of numericItems){
        const key = String(ni.p.numericToken);
        if(!numMap.has(key)) numMap.set(key, []);
        numMap.get(key).push(ni);
      }

      // synthesize season/ep assignments
      const synthesized = [];
      for(const [numKey, arr] of numMap.entries()){
        // sort by lastModified ascending so oldest => season1, next => season2, ...
        arr.sort((a,b) => toNum(a.it.lastModified) - toNum(b.it.lastModified));
        if(arr.length === 1){
          const item = arr[0].it;
          item.__synth = { season: 1, ep: Number(numKey) };
          synthesized.push(item);
        } else {
          for(let i=0;i<arr.length;i++){
            const item = arr[i].it;
            item.__synth = { season: i+1, ep: Number(numKey) };
            synthesized.push(item);
          }
        }
      }

      // push group header
      out.push({ __groupHeader:true, base:g.base, newest:g.newest });

      const seasonMap = new Map();
      function pushToSeason(sKey, item){ const arr = seasonMap.get(sKey) || []; arr.push(item); seasonMap.set(sKey, arr); }

      // explicit season items
      for(const it of explicitSeason){
        const p = parseParts(it.name || '');
        const s = (p.season != null) ? p.season : (p.hasEp ? 1 : 'base');
        it.__displaySeason = (p.season != null) ? p.season : (p.hasEp ? 1 : null);
        it.__displayEp = (p.ep != null) ? p.ep : (p.hasEp ? p.ep : null);
        pushToSeason(s, it);
      }

      // synthesized numeric items
      for(const it of synthesized){
        const s = it.__synth.season != null ? it.__synth.season : 1;
        it.__displaySeason = s;
        it.__displayEp = it.__synth.ep;
        pushToSeason(s, it);
      }

      // base only
      for(const it of baseOnly) pushToSeason('base', it);

      // sort seasons
      const seasonKeys = Array.from(seasonMap.keys()).sort((a,b) => {
        if(a === 'base') return 1;
        if(b === 'base') return -1;
        return Number(a) - Number(b);
      });

      for(const sk of seasonKeys){
        const items = seasonMap.get(sk) || [];
        out.push({ __seasonHeader:true, season: sk, seasonLabel: (sk === 'base' ? 'Base' : ('Saison ' + sk)), note:'' });

        const epBuckets = new Map();
        for(const it of items){
          const p = parseParts(it.name || '');
          let epKey;
          if(p.hasEp && p.ep != null) epKey = Number(p.ep);
          else if(it.__displayEp != null) epKey = Number(it.__displayEp);
          else if(p.hasSeason) epKey = 0;
          else epKey = 'base';
          const arr = epBuckets.get(epKey) || [];
          arr.push(it);
          epBuckets.set(epKey, arr);
        }

        const epKeys = Array.from(epBuckets.keys()).sort((a,b)=>{
          if(a === 'base') return 1;
          if(b === 'base') return -1;
          if(a === 0 && b !== 0) return -1;
          if(b === 0 && a !== 0) return 1;
          return Number(a) - Number(b);
        });

        for(const ek of epKeys){
          const arr = epBuckets.get(ek) || [];
          arr.sort((x,y)=> toNum(y.lastModified) - toNum(x.lastModified));
          arr.forEach((it, idx) => it.__isNewestForEpisode = (idx === 0));
          for(const it of arr) out.push(it);
        }
      }
    }

    return out;
  }

  function copyText(text){
    if(!text) return;
    if(navigator.clipboard && navigator.clipboard.writeText) navigator.clipboard.writeText(text).catch(()=>{});
    else{
      const ta = document.createElement('textarea'); ta.value = text; ta.style.position = 'fixed'; ta.style.left='-9999px'; document.body.appendChild(ta);
      ta.select(); try{ document.execCommand('copy'); }catch(e){} ta.remove();
    }
  }

  function insertSoftBreaks(str,maxLen=40){
    if(!str) return '';
    return str.replace(/\S+/g, (chunk) => {
      if(chunk.length <= maxLen) return chunk;
      let out = '';
      for(let i=0;i<chunk.length;i+=maxLen){ out += chunk.slice(i,i+maxLen); if(i+maxLen<chunk.length) out += '\u200b'; }
      return out;
    });
  }

  function copyGroup(baseKey){
    if(!baseKey) return;
    const files = (window.allFiles||[]).filter(f=>{
      try{ return parseParts(f.name||'').base === baseKey; } catch(e){ return false; }
    }).filter(f=>f.url);
    if(!files.length){ copyText(`Aucun fichier trouvé pour: ${baseKey}`); return; }

    // mirror grouping logic (simplified) to format output
    const parsed = files.map(f=>({f,p:parseParts(f.name||'')}));
    const explicitSeason = parsed.filter(x => x.p.hasSeason || x.p.hasEp).map(x=>x.f);
    const numericItems = parsed.filter(x => !(x.p.hasSeason || x.p.hasEp) && x.p.numericToken != null);
    const baseOnly = parsed.filter(x => !(x.p.hasSeason || x.p.hasEp) && x.p.numericToken == null).map(x=>x.f);

    const numMap = new Map();
    for(const ni of numericItems){
      const key = String(ni.p.numericToken);
      if(!numMap.has(key)) numMap.set(key, []);
      numMap.get(key).push(ni);
    }

    const synthesized = [];
    for(const [numKey, arr] of numMap.entries()){
      arr.sort((a,b) => toNum(a.f.lastModified) - toNum(b.f.lastModified));
      if(arr.length === 1){
        arr[0].f.__synth = { season:1, ep:Number(numKey) };
        synthesized.push(arr[0].f);
      } else {
        for(let i=0;i<arr.length;i++){
          arr[i].f.__synth = { season:i+1, ep:Number(numKey) };
          synthesized.push(arr[i].f);
        }
      }
    }

    const seasonMap = new Map();
    function pushToSeason(sKey, item){ const arr = seasonMap.get(sKey) || []; arr.push(item); seasonMap.set(sKey, arr); }
    for(const it of explicitSeason){
      const p = parseParts(it.name||'');
      const s = (p.season != null) ? p.season : (p.hasEp ? 1 : 'base');
      it.__displaySeason = (p.season != null) ? p.season : (p.hasEp ? 1 : null);
      it.__displayEp = (p.ep != null) ? p.ep : (p.hasEp ? p.ep : null);
      pushToSeason(s, it);
    }
    for(const it of synthesized){ const s = it.__synth.season; it.__displaySeason = s; it.__displayEp = it.__synth.ep; pushToSeason(s, it); }
    for(const it of baseOnly) pushToSeason('base', it);

    const seasonKeys = Array.from(seasonMap.keys()).sort((a,b) => {
      if(a === 'base') return 1;
      if(b === 'base') return -1;
      return Number(a) - Number(b);
    });

    let out = '';
    const prettyBase = (baseKey || '(sans nom)').replace(/[_\-\s]+/g,' ').trim();
    for(const sk of seasonKeys){
      const arr = seasonMap.get(sk) || [];
      arr.sort((a,b) => {
        const pa = parseParts(a.name||''), pb = parseParts(b.name||'');
        const ea = pa.ep != null ? Number(pa.ep) : (a.__displayEp != null ? Number(a.__displayEp) : 999999);
        const eb = pb.ep != null ? Number(pb.ep) : (b.__displayEp != null ? Number(b.__displayEp) : 999999);
        if(ea !== eb) return ea - eb;
        return toNum(b.lastModified) - toNum(a.lastModified);
      });
      for(const f of arr){
        const p = parseParts(f.name||'');
        if(sk === 'base'){
          out += `${prettyBase} Base\n${f.name || '(sans nom)'}\nUrl\n${f.url || ''}\n\n`;
        } else {
          const sNum = (f.__displaySeason != null) ? f.__displaySeason : sk;
          const eNum = (f.__displayEp != null) ? f.__displayEp : (p.ep != null ? p.ep : '');
          out += `${prettyBase} Saison ${sNum} ep ${eNum}\n${f.name || '(sans nom)'}\nUrl\n${f.url || ''}\n\n`;
        }
      }
    }
    copyText(out.trim());
  }

  function renderNextChunk(){
    const listEl = document.getElementById('fileList');
    const source = (window.viewFiles && window.viewFiles.length) ? window.viewFiles : buildOrderedList(window.allFiles||[]);
    if(renderedCount >= source.length) return;
    const frag = document.createDocumentFragment();
    const limit = Math.min(source.length, Math.min(CONFIG.MAX_RENDER, renderedCount + CONFIG.CHUNK_SIZE));
    let videoCount = 0;
    for(let i = renderedCount; i < limit; i++){
      const f = source[i];
      if(f.__groupHeader){ frag.appendChild(createCardElement(f,false)); continue; }
      const isVideo = isVideoFile(f.name||'');
      const createVideo = isVideo ? (videoCount < CONFIG.MAX_VIDEOS_RENDER) : false;
      const card = createCardElement(f, createVideo);
      if(isVideo && createVideo) videoCount++;
      frag.appendChild(card);
    }
    renderedCount = limit;
    listEl.appendChild(frag);
    updateEmpty(); updateSentinel();
  }

  function updateSentinel(){
    const listEl = document.getElementById('fileList');
    let sentinel = document.getElementById('render-sentinel');
    if(!sentinel){
      sentinel = document.createElement('div'); sentinel.id='render-sentinel'; sentinel.style.width='1px'; sentinel.style.height='1px'; sentinel.style.opacity='0';
      listEl.appendChild(sentinel); ensureSentinelObserver(); sentinelObserver.observe(sentinel);
    } else listEl.appendChild(sentinel);
  }

  function ensureSentinelObserver(){
    if(sentinelObserver) return;
    sentinelObserver = new IntersectionObserver(entries => { entries.forEach(e => { if(e.isIntersecting) {
      if(CONFIG.AUTO_FLUSH_ON_SCROLL) flushSilentCache(CONFIG.FLUSH_BATCH_ON_SCROLL);
      renderNextChunk();
    } }); }, { root:null, rootMargin:'600px', threshold:0.01 });
  }

  function updateEmpty(){
    const empty = document.getElementById('emptyMessage');
    const len = (window.viewFiles && window.viewFiles.length) ? window.viewFiles.filter(x=>!x.__groupHeader).length : buildOrderedList(window.allFiles||[]).filter(x=>!x.__groupHeader).length;
    empty.style.display = (len === 0) ? 'block' : 'none';
  }

  function fullRerender(){ renderedCount = 0; document.getElementById('fileList').innerHTML = ''; renderNextChunk(); }

  function applySearchAndRender(){
    const q = (document.getElementById('searchInput').value || '').trim().toLowerCase();
    const ordered = buildOrderedList(window.allFiles || []);
    if(q){
      window.viewFiles = ordered.filter(f => {
        if(f.__groupHeader) return (f.base||'').toLowerCase().includes(q);
        return ((f.name||'').toLowerCase().includes(q) || (f.url||'').toLowerCase().includes(q) || (parseParts(f.name||'').base||'').toLowerCase().includes(q));
      });
    } else window.viewFiles = [];
    renderedCount = 0; document.getElementById('fileList').innerHTML = ''; renderNextChunk();
  }

  function debounce(fn,ms=150){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }
  document.getElementById('searchInput').addEventListener('input', debounce(applySearchAndRender,140));

  async function loadFiles(){
    try{
      const res = await fetch(CONFIG.FILES_PATH, { cache:'no-store' });
      if(!res.ok) throw new Error('fetch failed');
      const files = await res.json();
      const normalized = (files||[]).map(f => ({ name:f.name, url:f.url, size:toNum(f.size), lastModified:toNum(f.lastModified), thumbnail:f.thumbnail||null }));
      const seen = new Set(), unique = [];
      for(const it of normalized){ if(!it.url) continue; if(!seen.has(it.url)){ seen.add(it.url); unique.push(it); } }
      window.allFiles = unique.slice(0, CONFIG.METADATA_CAP);
      fullRerender();
    }catch(e){ console.error(e); }
  }

  function handleServerMsg(msg){
    if(!msg || !msg.type) return;
    const normFile = f => ({ name:f.name, url:f.url, size: toNum(f.size), lastModified: toNum(f.lastModified), thumbnail: f.thumbnail || null });

    if(msg.type === 'full' && Array.isArray(msg.files)){
      const arr = msg.files.map(normFile);
      const seen = new Set(), unique = [];
      for(const it of arr){ if(!it.url) continue; if(!seen.has(it.url)){ seen.add(it.url); unique.push(it); } }
      window.allFiles = unique.slice(0, CONFIG.METADATA_CAP);
      fullRerender(); return;
    }

    if((msg.type === 'add' || msg.type === 'update') && msg.file){
      const file = normFile(msg.file);
      if(isImageFile(file.name)){
        window.allFiles = (window.allFiles || []).filter(x => x.url !== file.url);
        window.allFiles.unshift(file);
        if(window.allFiles.length > CONFIG.METADATA_CAP) window.allFiles.length = CONFIG.METADATA_CAP;
        fullRerender(); return;
      }
      const existingIdx = (window.allFiles || []).findIndex(x => x.url === file.url);
      if(existingIdx !== -1) window.allFiles[existingIdx] = file; else window.allFiles = [file].concat(window.allFiles || []);
      // dedupe
      const uniq = []; const seenUrls = new Set();
      for(const it of window.allFiles){ if(!it || !it.url) continue; if(seenUrls.has(it.url)) continue; seenUrls.add(it.url); uniq.push(it); }
      window.allFiles = uniq;
      fullRerender(); return;
    }

    if(msg.type === 'remove'){
      const ident = msg.url || msg.name;
      window.allFiles = (window.allFiles||[]).filter(x => x.url !== ident);
      fullRerender(); return;
    }

    if(msg.type === 'notify' && Array.isArray(msg.files)){
      let anyImmediate = false;
      for(const f of msg.files){
        const file = normFile(f);
        if(isImageFile(file.name)){ window.allFiles = (window.allFiles || []).filter(x => x.url !== file.url); window.allFiles.unshift(file); anyImmediate = true; }
        else { const existing = (window.allFiles || []).findIndex(x=>x.url===file.url); if(existing !== -1) window.allFiles[existing] = file; else window.allFiles = [file].concat(window.allFiles || []); anyImmediate = true; }
      }
      if(anyImmediate){
        if(window.allFiles.length > CONFIG.METADATA_CAP) window.allFiles.length = CONFIG.METADATA_CAP;
        const uniq2=[]; const s2=new Set();
        for(const it of window.allFiles){ if(!it || !it.url) continue; if(s2.has(it.url)) continue; s2.add(it.url); uniq2.push(it); }
        window.allFiles = uniq2;
        fullRerender();
      } else updateNewIndicator();
      return;
    }
  }

  function bufferAndFlush(msg){ pendingMsgs.push(msg); }
  setInterval(()=> {
    if(!pendingMsgs.length) return;
    const batch = pendingMsgs.splice(0,pendingMsgs.length);
    for(const m of batch) try{ handleServerMsg(m); } catch(e){ console.error(e); }
  }, CONFIG.BATCH_FLUSH_MS);

  function connectWebSocket(){
    try{ ws = new WebSocket(CONFIG.WS_PATH); } catch(e){ ws=null; startSSE(); startPolling(); return; }
    ws.addEventListener('open', ()=>{ reconnectAttempts = 0; try{ ws.send(JSON.stringify({ type:'subscribe', channel:'files' })); } catch(e){} });
    ws.addEventListener('message', ev => { try{ const msg = JSON.parse(ev.data); bufferAndFlush(msg); } catch(e){ console.error(e); } });
    ws.addEventListener('close', ()=>{ ws=null; startSSE(); scheduleReconnect(); });
    ws.addEventListener('error', ()=>{ try{ ws.close(); } catch(e){} });
  }
  function scheduleReconnect(){ reconnectAttempts++; const delay = Math.min(30000, 1000 * Math.pow(1.6, Math.min(10,reconnectAttempts))); setTimeout(()=>{ if(!ws) connectWebSocket(); }, delay); }

  function startSSE(){
    if(typeof EventSource === 'undefined'){ startPolling(); return; }
    if(es) return;
    try{ es = new EventSource(CONFIG.SSE_PATH); } catch(e){ es=null; startPolling(); return; }
    es.onmessage = ev => { try{ const msg = JSON.parse(ev.data); bufferAndFlush(msg); } catch(e){ console.error(e); } };
    es.onerror = ()=>{ try{ es.close(); } catch(e){} es=null; startPolling(); };
  }

  function startPolling(){
    if(pollTimer) return;
    pollTimer = setInterval(()=> {
      fetch(CONFIG.FILES_PATH, { cache:'no-store' })
        .then(res => res.ok ? res.json() : Promise.reject('err'))
        .then(files => {
          const arr = (files||[]).map(f=>({ name:f.name, url:f.url, size:toNum(f.size), lastModified: toNum(f.lastModified), thumbnail:f.thumbnail||null }));
          const seen = new Set(), unique = [];
          for(const it of arr){ if(!it.url) continue; if(!seen.has(it.url)){ seen.add(it.url); unique.push(it); } }
          window.allFiles = unique.slice(0, CONFIG.METADATA_CAP);
          fullRerender();
        }).catch(()=>{});
    }, CONFIG.POLL_INTERVAL_MS);
  }
  function stopPolling(){ if(pollTimer){ clearInterval(pollTimer); pollTimer = null; } }

  function copyUrl(url){ if(!url) return; if(navigator.clipboard && navigator.clipboard.writeText) navigator.clipboard.writeText(url).catch(()=>{}); else { const ta=document.createElement('textarea'); ta.value=url; document.body.appendChild(ta); ta.select(); try{ document.execCommand('copy'); }catch(e){} ta.remove(); } }
  window.copyUrl = copyUrl;

  function mergeSilentToAll(count=1){
    if(!silentLogCache.length) return 0;
    const items = silentLogCache.splice(0,count);
    const existingUrls = new Set((window.allFiles||[]).map(x=>x.url));
    const toAdd = items.filter(it => !existingUrls.has(it.url) && !isImageFile(it.name));
    if(!toAdd.length) return 0;
    const prevScrollY = window.scrollY || 0;
    const prevDocH = document.documentElement.scrollHeight || 0;
    window.allFiles = toAdd.concat(window.allFiles).slice(0, CONFIG.METADATA_CAP);
    renderedCount = 0;
    const listEl = document.getElementById('fileList');
    listEl.innerHTML = '';
    renderNextChunk();
    const newDocH = document.documentElement.scrollHeight || 0;
    const delta = newDocH - prevDocH;
    window.scrollTo(0, Math.max(0, prevScrollY + delta));
    updateNewIndicator();
    return toAdd.length;
  }

  function flushSilentCache(n = CONFIG.FLUSH_BATCH_ON_SCROLL){
    const flushCount = Math.min(n, silentLogCache.length);
    if(flushCount <= 0) return 0;
    return mergeSilentToAll(flushCount);
  }

  function updateNewIndicator(){
    const count = silentLogCache.filter(f => !isImageFile(f.name)).length;
    const badge = document.getElementById('newIndicator');
    const showBtn = document.getElementById('showNewBtn');
    document.getElementById('newCount').textContent = String(count);
    if(count > 0){ badge.style.display='inline-block'; showBtn.style.display='inline-block'; }
    else { badge.style.display='none'; showBtn.style.display='none'; }
  }

  document.getElementById('showNewBtn').addEventListener('click',()=>{
    const toFlush = Math.min(50, silentLogCache.length);
    mergeSilentToAll(toFlush);
    if(silentLogCache.length) updateNewIndicator();
  });

  setInterval(()=>{
    if(silentLogCache.length && !document.hidden){
      if(CONFIG.AUTO_FLUSH_ON_SCROLL){
        mergeSilentToAll(Math.min(1, silentLogCache.length));
      }
      updateNewIndicator();
    }
  }, CONFIG.SILENT_FLUSH_INTERVAL_MS);

  function connectInitial(){
    loadFiles();
    connectWebSocket();
    setTimeout(()=>{ if(!ws) startSSE(); }, 1500);
    setTimeout(()=>{ if(!ws && !es) startPolling(); }, 2500);
    window.addEventListener('beforeunload', ()=>{ try{ if(ws) ws.close(); }catch(e){} try{ if(es) es.close(); }catch(e){} stopPolling(); });
  }

  connectInitial();
})();
</script>
</body>
</html>
